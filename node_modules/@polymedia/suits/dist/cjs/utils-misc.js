"use strict";
/* Miscellaneous utils */
Object.defineProperty(exports, "__esModule", { value: true });
exports.sleep = exports.makeRanges = exports.log = exports.formatNumber = exports.formatBigInt = exports.convertBigIntToNumber = exports.convertNumberToBigInt = exports.chunkArray = void 0;
/**
 * Split an array into multiple chunks of a certain size.
 */
function chunkArray(array, chunkSize) {
    const chunks = [];
    for (let i = 0; i < array.length; i += chunkSize) {
        const chunk = array.slice(i, i + chunkSize);
        chunks.push(chunk);
    }
    return chunks;
}
exports.chunkArray = chunkArray;
/**
 * Convert a number to a bigint, scaled to the specified decimals.
 */
function convertNumberToBigInt(num, decimals) {
    const numScaledAsString = (num * 10 ** decimals).toFixed(0);
    return BigInt(numScaledAsString);
}
exports.convertNumberToBigInt = convertNumberToBigInt;
/**
 * Convert a bigint to a number, scaled down to the specified decimals.
 */
function convertBigIntToNumber(big, decimals) {
    return Number(big) / 10 ** decimals;
}
exports.convertBigIntToNumber = convertBigIntToNumber;
/**
 * Format a bigint into a readable string, scaled down to the specified decimals.
 * @see formatNumber
 */
function formatBigInt(big, decimals, format = "standard") {
    const num = convertBigIntToNumber(big, decimals);
    return formatNumber(num, format);
}
exports.formatBigInt = formatBigInt;
/**
 * Format a number into a readable string.
 *
 * - 'standard' format:
 *   - If the number is < 1000, show 2 decimals (e.g. '123.45')
 *   - If the number is >= 1000, don't show any decimals (e.g. '1,234')
 *
 * - 'compact' format:
 *   - If the number is < 1 million, use 'standard' format
 *   - If the number is >= 1 million, use word notation (e.g. '540.23M', '20.05B')
 */
function formatNumber(num, format = "standard") {
    if (format === "standard") {
        return formatNumberStandard(num);
    }
    else {
        return formatNumberCompact(num);
    }
}
exports.formatNumber = formatNumber;
function formatNumberStandard(num) {
    if (num < 1) {
        return String(num);
    }
    else if (num < 1000) {
        return num.toLocaleString("en-US", { minimumFractionDigits: 2, maximumFractionDigits: 2 });
    }
    else {
        return num.toLocaleString("en-US", { maximumFractionDigits: 0 });
    }
}
function formatNumberCompact(num) {
    if (num < 1_000_000) {
        return formatNumberStandard(num);
    }
    else if (num < 1_000_000_000) {
        return formatNumberStandard(num / 1_000_000) + "M";
    }
    else if (num < 1_000_000_000_000) {
        return formatNumberStandard(num / 1_000_000_000) + "B";
    }
    else {
        return formatNumberStandard(num / 1_000_000_000_000) + "T";
    }
}
/**
 * Log a message including the current date and time.
 */
function log(level, ...data) {
    const date = new Date();
    const year = date.getFullYear().toString().slice(-2);
    const month = (date.getMonth() + 1).toString().padStart(2, "0");
    const day = date.getDate().toString().padStart(2, "0");
    const hours = date.getHours().toString().padStart(2, "0");
    const minutes = date.getMinutes().toString().padStart(2, "0");
    const seconds = date.getSeconds().toString().padStart(2, "0");
    const dateStr = `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;
    console[level](`${dateStr} |`, ...data);
}
exports.log = log;
/**
 * Generate an array of ranges of a certain size between two numbers.
 *
 * For example, calling `makeRanges(0, 678, 250)` will return:
 * ```
 * [ [ 0, 250 ], [ 250, 500 ], [ 500, 678 ] ]
 * ```
 */
function makeRanges(from, to, size) {
    const ranges = [];
    for (let start = from; start < to; start += size) {
        const end = Math.min(start + size, to);
        ranges.push([start, end]);
    }
    return ranges;
}
exports.makeRanges = makeRanges;
/**
 * Wait for a number of milliseconds.
 */
async function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}
exports.sleep = sleep;
//# sourceMappingURL=utils-misc.js.map