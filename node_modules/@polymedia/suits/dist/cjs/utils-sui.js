"use strict";
/* Sui utils */
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateAndNormalizeSuiAddress = exports.shortenSuiAddress = exports.requestSuiFromFaucet = exports.removeLeadingZeros = exports.makeExplorerUrl = exports.getSuiObjectResponseFields = exports.getCoinOfValue = exports.generateRandomAddress = exports.fetchAllDynamicFields = exports.devInspectAndGetReturnValues = exports.devInspectAndGetResults = void 0;
const bcs_1 = require("@mysten/sui.js/bcs");
const utils_1 = require("@mysten/sui.js/utils");
const utils_misc_js_1 = require("./utils-misc.js");
/**
 * Call `SuiClient.devInspectTransactionBlock()` and return the results.
 */
async function devInspectAndGetResults(suiClient, txb, sender = "0x7777777777777777777777777777777777777777777777777777777777777777") {
    const resp = await suiClient.devInspectTransactionBlock({
        sender: sender,
        transactionBlock: txb
    });
    if (resp.error) {
        throw Error(`response error: ${JSON.stringify(resp, null, 2)}`);
    }
    if (!resp.results?.length) {
        throw Error(`response has no results: ${JSON.stringify(resp, null, 2)}`);
    }
    return resp.results;
}
exports.devInspectAndGetResults = devInspectAndGetResults;
/**
 * Call `SuiClient.devInspectTransactionBlock()` and return the deserialized return values.
 * @returns An array with the deserialized return values of each transaction in the TransactionBlock.
 */
async function devInspectAndGetReturnValues(suiClient, txb, sender = "0x7777777777777777777777777777777777777777777777777777777777777777") {
    const results = await devInspectAndGetResults(suiClient, txb, sender);
    /** The values returned from each of the transactions in the TransactionBlock. */
    const blockReturnValues = [];
    for (const txnResult of results) {
        if (!txnResult.returnValues?.length) {
            throw Error(`transaction didn't return any values: ${JSON.stringify(txnResult, null, 2)}`);
        }
        /** The values returned from the transaction (a function can return multiple values). */
        const txnReturnValues = [];
        for (const value of txnResult.returnValues) {
            const valueData = Uint8Array.from(value[0]);
            const valueType = value[1];
            let valueDeserialized;
            if (valueType === "0x1::string::String") {
                valueDeserialized = bcs_1.bcs.string().parse(valueData);
            }
            else if (valueType === "vector<0x1::string::String>") {
                valueDeserialized = bcs_1.bcs.vector(bcs_1.bcs.string()).parse(valueData);
            }
            else {
                valueDeserialized = bcs_1.bcs.de(valueType, valueData, "hex");
            }
            txnReturnValues.push(valueDeserialized);
        }
        blockReturnValues.push(txnReturnValues);
    }
    return blockReturnValues;
}
exports.devInspectAndGetReturnValues = devInspectAndGetReturnValues;
/**
 * Get all dynamic object fields owned by an object.
 */
async function fetchAllDynamicFields(suiClient, parentId, sleepBetweenRequests = 333, // milliseconds
verbose = false) {
    const allFieldsInfo = [];
    let hasNextPage = true; // type cast so ESLint doesn't complain about 'no-unnecessary-condition'
    let cursor = null;
    let pageNumber = 1;
    while (hasNextPage) {
        if (verbose) {
            console.log(`Fetching page ${pageNumber}`);
        }
        pageNumber++;
        await suiClient.getDynamicFields({ parentId, cursor })
            .then(async (page) => {
            allFieldsInfo.push(...page.data);
            hasNextPage = page.hasNextPage;
            cursor = page.nextCursor;
            if (sleepBetweenRequests > 0) {
                await (0, utils_misc_js_1.sleep)(sleepBetweenRequests); // give the RPC a break
            }
        });
    }
    return allFieldsInfo;
}
exports.fetchAllDynamicFields = fetchAllDynamicFields;
/**
 * Generate a random Sui address (for development only).
 */
function generateRandomAddress() {
    // Function to generate a random byte in hexadecimal format
    const randomByteHex = () => Math.floor(Math.random() * 256).toString(16).padStart(2, "0");
    // Generate 32 random bytes and convert each to hex
    const address = "0x" + Array.from({ length: 32 }, randomByteHex).join("");
    return address;
}
exports.generateRandomAddress = generateRandomAddress;
/**
 * Get a `Coin<T>` of a given value from the owner. Handles coin merging and splitting.
 * Assumes that the owner has enough balance.
 */
async function getCoinOfValue(suiClient, txb, ownerAddress, coinType, coinValue) {
    let coinOfValue;
    coinType = removeLeadingZeros(coinType);
    if (coinType === "0x2::sui::SUI") {
        coinOfValue = txb.splitCoins(txb.gas, [txb.pure(coinValue)]);
    }
    else {
        const paginatedCoins = await suiClient.getCoins({ owner: ownerAddress, coinType });
        // if (paginatedCoins.hasNextPage) // TODO
        // Merge all coins into one
        const [firstCoin, ...otherCoins] = paginatedCoins.data;
        const firstCoinInput = txb.object(firstCoin.coinObjectId);
        if (otherCoins.length > 0) {
            txb.mergeCoins(firstCoinInput, otherCoins.map(coin => coin.coinObjectId));
        }
        coinOfValue = txb.splitCoins(firstCoinInput, [txb.pure(coinValue)]);
    }
    return coinOfValue;
}
exports.getCoinOfValue = getCoinOfValue;
/**
 * Validate a SuiObjectResponse and return its content.
 * @param resp A `SuiObjectResponse` from `SuiClient.getObject()` / `.multiGetObjects()` / `.getDynamicFieldObject()`
 * @param typeRegex (optional) A regular expression to check that `resp.data.content.type` has the right type
 * @returns The contents of `resp.data.content.fields`
 */
function getSuiObjectResponseFields(resp, typeRegex) {
    if (resp.error) {
        throw Error(`response error: ${JSON.stringify(resp, null, 2)}`);
    }
    if (resp.data?.content?.dataType !== "moveObject") {
        throw Error(`content missing: ${JSON.stringify(resp, null, 2)}`);
    }
    if (typeRegex && !new RegExp(typeRegex).test(resp.data.content.type)) {
        throw Error(`wrong object type: ${JSON.stringify(resp, null, 2)}`);
    }
    return resp.data.content.fields; // eslint-disable-line @typescript-eslint/no-explicit-any
}
exports.getSuiObjectResponseFields = getSuiObjectResponseFields;
/**
 * Build a Polymedia Explorer URL, like 'https://explorer.polymedia.app/address/0x123...456?network=testnet'
 */
function makeExplorerUrl(network, kind, address) {
    const baseUrl = (network === "localnet" || network == "http://127.0.0.1:9000")
        ? "http://localhost:3000"
        : "https://explorer.polymedia.app";
    let url = `${baseUrl}/${kind}/${address}`;
    if (network !== "mainnet") {
        const networkLabel = network === "localnet" ? "local" : network;
        url += `?network=${networkLabel}`;
    }
    return url;
}
exports.makeExplorerUrl = makeExplorerUrl;
/**
 * Remove leading zeros from a Sui address (lossless). For example it will turn
 * '0x0000000000000000000000000000000000000000000000000000000000000002' into '0x2'.
 */
function removeLeadingZeros(address) {
    return address.replaceAll(/0x0+/g, "0x");
}
exports.removeLeadingZeros = removeLeadingZeros;
/**
 * Get SUI from the faucet on localnet/devnet/testnet.
 */
async function requestSuiFromFaucet(network, address) {
    let faucetUrl;
    if (network == "localnet") {
        faucetUrl = "http://127.0.0.1:9123/gas";
    }
    else if (network == "devnet") {
        faucetUrl = "https://faucet.devnet.sui.io/v1/gas";
    }
    else { // network == 'testnet'
        faucetUrl = "https://faucet.testnet.sui.io/v1/gas";
    }
    return fetch(faucetUrl, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
            FixedAmountRequest: {
                recipient: address
            }
        }),
    });
}
exports.requestSuiFromFaucet = requestSuiFromFaucet;
/**
 * Abbreviate a Sui address for display purposes (lossy). Default format is '0x1234…5678',
 * given an address like '0x1234000000000000000000000000000000000000000000000000000000005678'.
 */
function shortenSuiAddress(text, start = 4, end = 4, separator = "…", prefix = "0x") {
    if (!text)
        return "";
    const addressRegex = /0[xX][a-fA-F0-9]{1,}/g;
    return text.replace(addressRegex, (match) => {
        // check if the address is too short to be abbreviated
        if (match.length - prefix.length <= start + end) {
            return match;
        }
        // otherwise, abbreviate the address
        return prefix + match.slice(2, 2 + start) + separator + match.slice(-end);
    });
}
exports.shortenSuiAddress = shortenSuiAddress;
/**
 * Validate a Sui address and return its normalized form, or `null` if invalid.
 */
function validateAndNormalizeSuiAddress(address) {
    if (address.length === 0) {
        return null;
    }
    const normalizedAddr = (0, utils_1.normalizeSuiAddress)(address);
    if (!(0, utils_1.isValidSuiAddress)(normalizedAddr)) {
        return null;
    }
    return normalizedAddr;
}
exports.validateAndNormalizeSuiAddress = validateAndNormalizeSuiAddress;
//# sourceMappingURL=utils-sui.js.map